
package Analisis;

import java.util.ArrayList;
import java_cup.runtime.*;

parser code
{:

    public ArrayList al = new ArrayList();
    public ArrayList erroresS = new ArrayList();
    public ArrayList erroresS1 = new ArrayList();


    /**Metodo al que se llama automáticamente ante algún error sintactico.*/
    public void syntax_error(Symbol s){
        String lexema = s.value.toString();
        int fila = s.right+1;
        int columna = s.left+1;
        
        System.err.println("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador '"
        +s.value + "' no reconocido." );


        erroresS.add("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador '"
        +s.value + "' no reconocido.\n");
    }

    /**Metodo al que se llama en el momento en que ya no es posible una recuperación de
    errores.*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        String lexema = s.value.toString();
        int fila = s.right+1;
        int columna = s.left+1;

        System.err.println("Error en la Línea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador '" +
        s.value + "' no reconocido.");
        
        erroresS1.add("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador '"
        +s.value + "' no reconocido.\n");
    }

    /*public Nodo getRaiz(){
        return action_obj.raiz;
    }*/

    

:}


action code {:
    //Nodo raiz=null;
    Sintactico sin = new Sintactico();
    ArrayList corchetes = new ArrayList();
    
:}

/*terminales reservados*/
terminal String corA,corC,resInt,resString,resPublic,resPrivate,resStatic,resBoolean,
                resChar,resDouble,resLong,resIf,resElse,resWhile,resFor,resDo,
                menorq,menorIgual,mayorq,mayorIgual,igual,coma,parentesisA,
                parentesisC,mas,menos,mul,div,and,or,not,resReturn,resObject,resImport,
                resProtected,resFinal,resClass,resSwitch,resCase,resBreak,resDefault,
                puntoYcoma,dosPuntos,parA,parC,punto,modulo;

terminal String entero,decimal,cadena,bool,iden,caracter;

/*
* Este terminal tiene un valor string. Recuerda que le dábamos el valor
* en el código del analizador léxico, al darle como parámetro un valor
* string al objeto Symbolo.
*/


/*
* Aquí están los no terminales
*/
non terminal INICIO,IMPORT,CLASS,EXPIMP,EXP,VALOR,TIPO,ACCESO,COD,MET,DECLARACION,
             ASIGNACION,SENTENCIAS,PARAM,COD2,LISTAID,OPREL,IGUALACION,SENTIF,LLAM,
             SENTELSE,SENTFOR,SENTWHILE,SENTDO,SENTSWITCH,EXPSENT,SALIDA,CASES,MAIN,
             INSTANCIA;


/* Precedencia */
precedence left mas, menos;
precedence left mul, div;
precedence left punto, modulo;
precedence left mayorq, menorq;
precedence left mayorIgual, menorIgual;
precedence left and, or, not;

/* ­­­­­­­­­­­­­­ Declaración de la gramática  ­­­­­­­­­­­ */
start with INICIO; // start with sirve para indicarle al parser con que produccion empezar

INICIO::=IMPORT
      |CLASS;

IMPORT::= resImport EXPIMP puntoYcoma {:parser.al.add("importacion\n");:} INICIO;

EXPIMP::= EXPIMP:val1 punto EXPIMP:val2 {:RESULT=val1+"."+val2;:}
        |EXPIMP:val1 punto mul {:RESULT=val1+".*";:}
        |iden:val {:RESULT=val;:};

IGUALACION::= mas igual
            | menos igual
            | mul igual
            | igual;

EXP::=EXP:val1 mas EXP:val2 {:RESULT=val1+"+"+val2;:}
    |EXP:val1 menos EXP:val2 {:RESULT=val1+"-"+val2;:}
    |EXP:val1 mul EXP:val2 {:RESULT=val1+"*"+val2;:}
    |EXP:val1 div EXP:val2 {:RESULT=val1+"/"+val2;:}
    |EXP:val1 modulo EXP:val2 {:RESULT=val1+"/"+val2;:}
    |parentesisA EXP parentesisC
    |VALOR mas mas
    |VALOR menos menos
    |VALOR:val {:RESULT=val;:};

EXPSENT::=OPREL and OPREL
         |OPREL or OPREL
         |not OPREL
         |OPREL;

OPREL::=EXP mayorq OPREL
       |EXP menorq OPREL
       |EXP mayorIgual OPREL
       |EXP menorIgual OPREL
       |EXP igual igual OPREL
       |EXP not igual OPREL
       |EXP;

VALOR::=entero:val {:RESULT=val;:} 
        |decimal:val {:RESULT=val;:}
        |cadena:val {:RESULT=val;:}
        |bool:val {:RESULT=val;:}
        |iden:val {:RESULT=val;:}
        |caracter:val {:RESULT=val;:};

CLASS::= ACCESO resClass iden parA {:parser.al.add("inicio de la clase\n");:} COD parC {:parser.al.add("fin de la clase\n");:}
        |;

COD::=MET COD
    |MAIN COD2
    |DECLARACION COD
    |ASIGNACION COD
    |SENTENCIAS COD
    |LLAM COD
    |;

COD2::=DECLARACION COD2
    |ASIGNACION COD2
    |SENTENCIAS COD2
    |LLAM COD2
    |;

MET::= ACCESO TIPO iden parentesisA PARAM parentesisC parA {:parser.al.add("inicio del metodo o funcion\n");:} COD2 SALIDA parC {:parser.al.add("fin del metodo o funcion\n");:};

MAIN::=resPublic resStatic iden iden parentesisA resString iden corA corC parentesisC parA {:parser.al.add("inicio del metodo main\n");:} COD2 parC {:parser.al.add("fin del metodo main\n");:};

DECLARACION::= ACCESO TIPO LISTAID puntoYcoma {:parser.al.add("declaracion de variables\n");:};

ASIGNACION::= ACCESO TIPO LISTAID IGUALACION EXP puntoYcoma {:parser.al.add("asignacion a variables no declaradas\n");:}
            | LISTAID IGUALACION EXP puntoYcoma {:parser.al.add("asignacion a variables previamente declaradas\n");:};

LISTAID::=iden:id2 {:RESULT=id2;:}
        |iden:id coma LISTAID:id1 {:RESULT=id+","+id1;:};

TIPO::=resInt:val 
    |resString:val 
    |resBoolean:val
    |resDouble:val
    |resChar:val 
    |resLong:val
    |resObject;

ACCESO::=resPublic:val
    |resPrivate:val 
    |resProtected:val
    |resStatic:val
    |resFinal:val
    |;

PARAM::=iden:val {:RESULT=val;:}
       |iden:val1 coma iden:val2 {:RESULT=val1+","+val2;:}
       |TIPO iden 
       |TIPO iden coma PARAM
       |;

SENTENCIAS::=SENTIF
            |SENTWHILE
            |SENTFOR
            |SENTSWITCH
            |SENTDO;

SENTIF::= resIf parentesisA EXPSENT parentesisC parA {:parser.al.add("inicio de la sentencia if\n");:} COD2 parC {:parser.al.add("fin de la sentencia if\n");:}
         |SENTIF SENTELSE;

SENTELSE::=resElse parA {:parser.al.add("inicio de la sentencia else\n");:} COD2 parC {:parser.al.add("fin de la sentencia else\n");:};

SENTFOR::=resFor parentesisA ASIGNACION puntoYcoma OPREL puntoYcoma EXP parentesisC parA {:parser.al.add("inicio de la sentencia for\n");:} COD2 SALIDA parC {:parser.al.add("fin de la sentencia for\n");:};

SENTWHILE::=resWhile parentesisA EXPSENT parentesisC parA {:parser.al.add("inicio de la sentencia while\n");:} COD2 SALIDA parC {:parser.al.add("fin de la sentencia while\n");:};

SENTDO::=resDo parA {:parser.al.add("inicio de la sentencia Do\n");:} COD2 parC resWhile parentesisA EXPSENT parentesisC puntoYcoma {:parser.al.add("fin de la sentencia Do\n");:};

SENTSWITCH::=resSwitch parentesisA EXP parentesisC parA {:parser.al.add("inicio de la sentencia switch\n");:} resCase VALOR dosPuntos COD2 resBreak CASES resDefault dosPuntos COD2 parC {:parser.al.add("fin de la sentencia switch\n");:};

CASES::= resCase VALOR dosPuntos COD2 resBreak puntoYcoma CASES
        |;

SALIDA::= resBreak puntoYcoma {:parser.al.add("break\n");:}
        | resReturn EXP puntoYcoma {:parser.al.add("return\n");:}
        |;

INSTANCIA::=iden iden igual iden iden parentesisA parentesisC puntoYcoma {:parser.al.add("instancia\n");:};

LLAM::=iden parentesisA PARAM parentesisC puntoYcoma {:parser.al.add("llamada de funcion\n");:};